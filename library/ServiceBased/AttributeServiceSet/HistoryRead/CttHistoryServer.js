/* All functions within this script exist to create new instances of core script library objects
   in as little as one line of code.

   Helper functions available:
    - HistoryRead.Execute: invoke an internal version of the HistoryRead service call; to get an "expected dataset"
    - HistoryRead.HistoryMatches: compares historical data generated by the CTT to values from a server. compares "expected" vs. "actual" datasets.
    - Server.TimeSlice.New: gets a new time-slice; 
        .next():     gets the next time-slice, based on the property 'ProcessingInterval'
*/
include( "./library/Base/safeInvoke.js" );
include( "./library/RunOnce/redefiners.js" );

OPCF.HA.Server = new Object();
OPCF.HA.Server = {

    Request: null,     // requestHeader 
    Response: null,    // responseHeader

    _handleCount: 0,
    NextHandle: function(){ return( this._handleCount++ ); },


    /* Execute: invokes an internal-version of the HistoryRead UA service call.
       Parameters:
       - rawData: the raw data to search through. Type is: DataValues.
       - args: extensible parameter containing:
           - NodesToRead               = [empty] an array of 'MonitoredItem' objects, to read.
           - HistoryReadDetails        = [empty] the HistoryReadDetails extensible parameter.
           - TimestampsToReturn        = [Both]  TimestampsToReturn enum.
           - ReleaseContinuationPoints = [true]  Boolean flag.
           - Aggregate: an aggregate definition object, e.g. 'UaReadRawModifiedDetails'
       Returns: True/False
    */
    Execute: function ( args ) {
            if( !isDefined( args ) ) throw( "CttHistoryRead.Execute args missing." );
            if( !isDefined( [ args.NodesToRead, args.HistoryReadDetails, args.TimestampsToReturn, args.ReleaseContinuationPoints ] ) ) throw( "CttHistoryRead.Execute args parameters incorrect." );
            this.Request = UaHistoryReadRequest.New( args );
            this.Response = new UaHistoryReadResponse();
            this.Response.ResponseHeader = UaResponseHeader.New( { RequestHandle: this.NextHandle(), ServiceResult: StatusCode.Good } );

            // in this server we now need to invoke the ACTUAL request to emulate what a REAL server will do
            for( var i=0; i<this.Request.NodesToRead.length; i++ ) {
                var histResult = new UaHistoryReadResult();
                switch( args.HistoryReadDetails.Name ) {
                    case "ReadRawModifiedDetails": {
                        var data = OPCF.HA.Analysis.Get.DataInTimeSlice( { RawData: args.NodesToRead, TimeSlice: new TimeSlice( args.HistoryReadDetails ), Debug: args.Debug } );
                        this.Response.Results[i] = UaHistoryReadResult.New( { StatusCode: StatusCode.Good, HistoryData: data } );
                        break;
                        }
                    case "ReadEventDetails": {
                        notImplemented( "NOT IMPLEMENTED/TODO: ReadEventDetails" );
                        break;
                        }
                    case "ReadProcessedDetails": {
                                            //TODO --below
                                            if( isDefined( args.HistoryReadDetails.AggregateConfiguration ) ) 
                                                addWarning( "TODO: Implement 'AggregateConfiguration'" );
                                            //TODO --above
                        var data = args.AggregateDefinition.GetDataset( { RawData: args.NodesToRead[i].RawValues, TimeSlice: new TimeSlice( args.HistoryReadDetails ), Debug: args.Debug } );
                        this.Response.Results[i] = UaHistoryReadResult.New( { StatusCode: StatusCode.Good, HistoryData: data } );
                        args.NodesToRead[i].ValueCTT = UaHistoryData.New( { DataValues: data } );
                        break;
                        }
                    case "ReadAtTimeDetails": {
                        notImplemented( "NOT IMPLEMENTED/TODO: ReadAtTimeDetails" );
                        break;
                        }
                    default: print( "\tunknown request" ); break;
                }
            }//for i

            return( true );
        },


    /* RecordsetsMatch: compares 2 sets of history data; 1 from the CTT, the other from the server
       Parameters:
            - Expected: the historical data returned by the CTT
            - Actual: the historical data returned by the server being tested.
       Returns: 
           true/false if the data matches 100%.
    */
    RecordsetsMatch: function( args ) {
            if( !isDefined( args ) ) throw( "[CttHAServer.RecordsetsMatch] args not specified." );
            if( !isDefined( args.Expected ) ) throw( "[CttHAServer.RecordsetsMatch] Expected not specified." );
            if( !isDefined( args.Actual ) ) throw( "[CttHAServer.RecordsetsMatch] Actual not specified." );
            if( !isDefined( args.Debug ) ) args.Debug = false;
            var result = true;
            if( args.Debug ) print( "RecordsetsMatch() Checking dataset: values expected (" + args.Expected.length + ") vs. actual (" + args.Actual.length + ") lengths... " + ( args.Expected.length === args.Actual.length? "ok" : "FAIL" ) );
            if( args.Expected.length !== args.Actual.length ) result = false;
            else for( var i=0; i<args.Expected.length; i++ ) if( !args.Expected[i].equals( args.Actual[i] ) ) result = false;
            // if failed, and debugging enabled, then lets show the differences:
            if( !result && args.Debug ) {
                print( "\nThe following rows in the recordset comparison did not match expectations..." );
                String.prototype.printArray( OPCF.HA.Server.RecordsetDiff( { Expected: CUVariables.Items[0].ValueCTT.DataValues, Actual: CUVariables.Items[0].Value, Debug: CUVariables.Debug } ) );
            }
            return( result );
        }, 

        /* RecordsetsDiff: compares two records (expected vs. actual) and returns a string array showing differences only.
           Parameters: 
                - Expected: the historical data returned by the CTT
                - Actual: the historical data returned by the server being tested.
           Returns: 
                - String[]: each string represents one entity that is different from expected. */
        RecordsetDiff: function( args ) {
            if( !isDefined( args ) ) throw( "[CttHAServer.RecordsetsMatch] args not specified." );
            if( !isDefined( args.Expected ) ) throw( "[CttHAServer.RecordsetsMatch] Expected not specified." );
            if( !isDefined( args.Actual ) ) throw( "[CttHAServer.RecordsetsMatch] Actual not specified." );
            if( !isDefined( args.Debug ) ) args.Debug = false;
            var result = [];
            for( var i=0; i<args.Expected.length; i++ ) {
                if( !args.Expected[i].equals( args.Actual[i] ) )
                    result.push( "[interval " + i + "] Expect: Tsvr=" + args.Expected[i].ServerTimestamp + "; Tsrc=" + args.Expected[i].SourceTimestamp + "; Val=" + args.Expected[i].Value + "; Q=" + args.Expected[i].StatusCode +
                            "\n[interval " + i + "] Actual: Tsvr=" + args.Actual[i].ServerTimestamp + "; Tsrc=" + args.Actual[i].SourceTimestamp + "; Val=" + args.Actual[i].Value + "; Q=" + args.Actual[i].StatusCode );
            }
            return( result );
        },

};

// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ TimeSlice ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ //

function TimeSlice( args ) {
    this.StartTime = isDefined( args ) && isDefined( args.StartTime ) ? args.StartTime : null;
    if( this.StartTime.clone === undefined ) this.StartTime = UaDateTime.fromHoursMinutesSecondsString( this.StartTime );
    this.ProcessingInterval = isDefined( args ) && isDefined( args.ProcessingInterval ) ? args.ProcessingInterval : 100;
    this.EndTime;
    if( isDefined( args.EndTime ) ) this.EndTime = args.EndTime;
    else {
        this.EndTime = this.StartTime.clone();
        this.EndTime.addMilliSeconds( this.ProcessingInterval );
    }
    this.Partial   = isDefined( args ) && isDefined( args.Partial )   ? args.Partial   : false;
    this.IsComplete= isDefined( args ) && isDefined( args.IsComplete )? args.IsComplete: false;
    this.toString = function() {
        return( "TimeSlice StartTime: " + this.StartTime + "; EndTime: " + this.EndTime + "; Partial: " + this.Partial +
            "; IsComplete: " + this.IsComplete + "; ProcessingInterval: " + this.ProcessingInterval );
    };// this.toString = function()
    this.clone = function() {
        var x = new TimeSlice( { StartTime: this.StartTime.clone(), ProcessingInterval: this.ProcessingInterval, EndTime: this.EndTime.clone() } );
        return( x );
    };// this.clone = function()
    this.first = function() {
        this.EndTime = this.StartTime.clone();
        this.EndTime.addMilliSeconds( this.ProcessingInterval );
        return( this );
    };// this.first = function()
    this.next = function() {
        this.StartTime.addMilliSeconds( this.ProcessingInterval );
        this.EndTime = this.StartTime.clone();
        this.EndTime.addMilliSeconds( this.ProcessingInterval );
        return( this );
    };// this.next() = function() 
}
OPCF.HA.Server.TimeSlice = new Object();
OPCF.HA.Server.TimeSlice.New = function( args ) { return( new TimeSlice( { StartTime: "00:00:10", ProcessingInterval: 10000 } ) ); }